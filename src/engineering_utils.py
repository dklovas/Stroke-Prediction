import pandas as pd
import numpy as np
from sklearn.preprocessing import (
    StandardScaler,
    MinMaxScaler,
    OneHotEncoder,
    FunctionTransformer,
    OrdinalEncoder,
    PolynomialFeatures,
)


scoring = {
    "accuracy": "accuracy",
    "precision": "precision",
    "recall": "recall",
    "f1": "f1",
    "roc_auc": "roc_auc",
}


def get_data_from_cross_validate(scores: dict) -> dict:
    """
    Extract metrics from cross-validation scores.

    Parameters:
        scores (dict): Dictionary containing cross-validation results for metrics like accuracy, precision, recall, etc.

    Returns:
        dict: A dictionary containing the mean of various metrics across cross-validation folds.
    """
    return {
            "Average Accuracy": scores["test_accuracy"].mean(),
            "Average Precision": scores["test_precision"].mean(),
            "Average Recall": scores["test_recall"].mean(),
            "Average f1": scores["test_f1"].mean(),
            "Average ROC AUC": scores["test_roc_auc"].mean(),
        }


def get_data_from_classification_report(
    report: dict, raport_type: int, model_name: str
) -> dict:
    """
    Extract metrics from a classification report.

    Parameters:
        report (dict): Classification report dictionary generated by `classification_report` with `output_dict=True`.
        raport_type (int): Type of the report, e.g., 1 for initial or 2 for tuned.
        model_name (str): Name of the model.

    Returns:
        dict: A dictionary containing classification metrics and model details.
    """
    return {
        "Model": model_name,
        "type": '(tuned)' if raport_type == 2 else '',
        "Precision (0)": report["0"]["precision"],
        "Recall (0)": report["0"]["recall"],
        "F1-Score (0)": report["0"]["f1-score"],
        "Precision (1)": report["1"]["precision"],
        "Recall (1)": report["1"]["recall"],
        "F1-Score (1)": report["1"]["f1-score"],
        "Accuracy": report["accuracy"],
        "Macro Avg F1": report["macro avg"]["f1-score"],
        "Weighted Avg F1": report["weighted avg"]["f1-score"],
    }


def clean_feature_columns(df: pd.DataFrame, features: list) -> None:
    """
    Clean feature columns by stripping whitespace and replacing empty strings with NaN.

    Parameters:
        df (pd.DataFrame): Input DataFrame.
        features (list): List of feature column names to clean.

    Returns:
        None: Modifies the DataFrame in place.
    """
    for col in features:
        df[col] = df[col].str.strip().replace("", np.nan)
        


def generate_polynomial_features(
    df: pd.DataFrame, columns: list, degree: int = 2
) -> pd.DataFrame:
    """
    Generate polynomial interaction features from a DataFrame.

    Parameters:
        df (pd.DataFrame): Input DataFrame.
        columns (list): Columns to generate polynomial features for.
        degree (int, optional): Degree of polynomial features. Defaults to 2.

    Returns:
        pd.DataFrame: DataFrame with generated polynomial features.
    """    
    poly = PolynomialFeatures(degree=degree, interaction_only=True, include_bias=False)
    poly_features = poly.fit_transform(df)
    feature_names = poly.get_feature_names_out(df.columns)

    poly_df = pd.DataFrame(poly_features, columns=feature_names)
    poly_df.drop(columns=columns, inplace=True)
    poly_df.columns = [f"poly_{name}" for name in poly_df.columns]
    return poly_df



def generate_aggregations(df: pd.DataFrame, group_by_column: str) -> pd.DataFrame:
    """
    Generate aggregated statistical features based on groupings.

    Parameters:
        df (pd.DataFrame): Input DataFrame.
        group_by_column (str): Column name to group data by.

    Returns:
        pd.DataFrame: DataFrame with aggregated features.
    """
    aggregated_features = df.groupby(group_by_column).agg({
        'age': ['mean', 'std'],
        'bmi': ['mean', 'std'],
        'avg_glucose_level': ['mean', 'std']
    }).reset_index()
    
    aggregated_features.columns = ['_'.join(col).strip() for col in aggregated_features.columns.values]
    aggregated_features = aggregated_features.round(2)
    return aggregated_features

def generate_ratio_features(df: pd.DataFrame) -> pd.DataFrame:
    """
    Generate ratio features by dividing specific columns.

    Parameters:
        df (pd.DataFrame): Input DataFrame with required columns ('age', 'bmi', 'avg_glucose_level').

    Returns:
        pd.DataFrame: DataFrame with added ratio features.
    """
    df['ratio_age_bmi'] = df['age'] / df['bmi']
    df['ratio_glucose_bmi'] = df['avg_glucose_level'] / df['bmi']
    return df

def generate_log_transform_features(
    df: pd.DataFrame, features: list
) -> pd.DataFrame:
    """
    Apply logarithmic transformation to selected features.

    Parameters:
        df (pd.DataFrame): Input DataFrame.
        features (list): List of feature column names to apply logarithmic transformation.

    Returns:
        pd.DataFrame: DataFrame with logarithmic transformed features.
    """
    for feature in features:
        df[f'log_{feature}'] = np.log(df[feature])

    return df

